{"ast":null,"code":"import _slicedToArray from \"/home/lambamansha/Desktop/minorproject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport cloneDeep from \"lodash/cloneDeep\";\nimport flatten from \"lodash/flatten\";\nimport range from \"lodash/range\";\nimport includes from \"lodash/includes\";\nconst VALUES = range(1, 10);\nconst DIM = range(0, 9);\nconst ZERO = 0;\n\nconst getRow = (grid, rowNum) => {\n  if (!includes(DIM, rowNum)) {\n    throw new Error(\"rowNum not in range\");\n  }\n\n  return grid[rowNum];\n};\n\nconst getCol = (grid, colNum) => {\n  if (!includes(DIM, colNum)) {\n    throw new Error(\"colNum not in range\");\n  }\n\n  return grid.map(row => row[colNum]);\n};\n\nconst getSquare = (grid, rowNum, colNum) => {\n  if (!includes(DIM, rowNum) || !includes(DIM, colNum)) {\n    throw new Error(\"rowNum or colNum are not in range\");\n  }\n\n  let rowStart = rowNum - rowNum % 3; // uppermost row index of the box\n\n  let colStart = colNum - colNum % 3; // leftmost col index of the box\n\n  let result = [];\n\n  for (let i = 0; i < 3; i++) {\n    result[i] = result[i] || [];\n\n    for (let j = 0; j < 3; j++) {\n      result[i].push(grid[rowStart + i][colStart + j]);\n    }\n  }\n\n  return flatten(result);\n};\n/*\n\tsudoku constraints checker\n\t- unique in its row\n\t- unique in its column\n\t- unique in its box\n*/\n\n\nconst check = (grid, number, rowNum, colNum) => {\n  if (!includes(DIM, rowNum) || !includes(DIM, colNum)) {\n    throw new Error(\"rowNum or colNum are not in range\");\n  }\n\n  if (!includes(VALUES, number)) {\n    throw new Error(\"number is not in range\");\n  }\n\n  let row = getRow(grid, rowNum);\n  let column = getCol(grid, colNum);\n  let square = getSquare(grid, rowNum, colNum);\n\n  if (!includes(row, number) && !includes(column, number) && !includes(square, number)) {\n    return true;\n  }\n\n  return false;\n};\n/*\n\tstarts from 0x0 and moves left to right and row by row to 9x9\n*/\n\n\nconst getNext = (rowNum = 0, colNum = 0) => {\n  return colNum !== 8 ? [rowNum, colNum + 1] : rowNum !== 8 ? [rowNum + 1, 0] : [0, 0];\n};\n/*\n\tRecursive formula that starts from [0, 0] and check\n\tall the possbile values for empty boxes until it reaches\n\tthe end of the grid and returns true\n\tor else if the grid is not solvable, it will return false\n*/\n\n\nexport const solver = (grid, rowNum = 0, colNum = 0) => {\n  if (includes(DIM, rowNum) < 0 || includes(DIM, colNum) < 0) {\n    throw new Error(\"rowNum or colNum are not in range\");\n  }\n\n  let isLast = rowNum >= 8 && colNum >= 8;\n  /* if the box is not empty, run the solver on the next box */\n\n  if (grid[rowNum][colNum] !== ZERO && !isLast) {\n    let _getNext = getNext(rowNum, colNum),\n        _getNext2 = _slicedToArray(_getNext, 2),\n        nextRowNum = _getNext2[0],\n        nextColNum = _getNext2[1];\n\n    return solver(grid, nextRowNum, nextColNum);\n  }\n  /*\n  if the box is empty, check to see out of numbers 1 to 9,\n  which one satisfies all three sudoko constraints\n  */\n\n\n  for (let i = 1; i <= 9; i++) {\n    if (check(grid, i, rowNum, colNum)) {\n      grid[rowNum][colNum] = i;\n\n      let _getNext3 = getNext(rowNum, colNum),\n          _getNext4 = _slicedToArray(_getNext3, 2),\n          nextRowNum = _getNext4[0],\n          nextColNum = _getNext4[1];\n      /*\n      runs the solver recusively until it sucessfully\n      reaches to the end of the grid, box 9x9\n      */\n\n\n      if (!nextRowNum && !nextColNum) {\n        // at index [8, 8], next would be [0, 0]\n        return true;\n      }\n\n      if (solver(grid, nextRowNum, nextColNum)) {\n        return true;\n      }\n    }\n  }\n  /*\n  if the loop could not solve and return the function,\n  false will be retuened which indicates the sudoku is not solvable.\n  resets the current state back to 0 allow for further tries\n  */\n\n\n  grid[rowNum][colNum] = ZERO;\n  return false;\n};\nexport const isSolvable = grid => {\n  let clonedGrid = cloneDeep(grid);\n  return solver(clonedGrid);\n};\n/*\n\tIf each of the numbers from 1 to 9 are repeated on the grid 9 times\n\tindicates the suduko is completed/solved\n*/\n\nexport const isComplete = grid => {\n  let values = flatten(grid);\n  let list = {};\n  values.map(val => list[val] = list[val] ? list[val] + 1 : 1);\n  delete list[\"0\"];\n  var total = Object.keys(list).reduce((total, key) => total + list[key], 0);\n  return total === 81 ? true : false;\n};","map":{"version":3,"sources":["/home/lambamansha/Desktop/minorproject/src/views/QuizList/utils/sudoku.js"],"names":["cloneDeep","flatten","range","includes","VALUES","DIM","ZERO","getRow","grid","rowNum","Error","getCol","colNum","map","row","getSquare","rowStart","colStart","result","i","j","push","check","number","column","square","getNext","solver","isLast","nextRowNum","nextColNum","isSolvable","clonedGrid","isComplete","values","list","val","total","Object","keys","reduce","key"],"mappings":"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","sourcesContent":["import cloneDeep from \"lodash/cloneDeep\";\nimport flatten from \"lodash/flatten\";\nimport range from \"lodash/range\";\n\nimport includes from \"lodash/includes\";\n\nconst VALUES = range(1, 10);\nconst DIM = range(0, 9);\nconst ZERO = 0;\n\nconst getRow = (grid, rowNum) => {\n  if (!includes(DIM, rowNum)) {\n    throw new Error(\"rowNum not in range\");\n  }\n  return grid[rowNum];\n};\n\nconst getCol = (grid, colNum) => {\n  if (!includes(DIM, colNum)) {\n    throw new Error(\"colNum not in range\");\n  }\n  return grid.map(row => row[colNum]);\n};\n\nconst getSquare = (grid, rowNum, colNum) => {\n  if (!includes(DIM, rowNum) || !includes(DIM, colNum)) {\n    throw new Error(\"rowNum or colNum are not in range\");\n  }\n  let rowStart = rowNum - (rowNum % 3); // uppermost row index of the box\n  let colStart = colNum - (colNum % 3); // leftmost col index of the box\n  let result = [];\n  for (let i = 0; i < 3; i++) {\n    result[i] = result[i] || [];\n    for (let j = 0; j < 3; j++) {\n      result[i].push(grid[rowStart + i][colStart + j]);\n    }\n  }\n  return flatten(result);\n};\n\n/*\n\tsudoku constraints checker\n\t- unique in its row\n\t- unique in its column\n\t- unique in its box\n*/\n\nconst check = (grid, number, rowNum, colNum) => {\n  if (!includes(DIM, rowNum) || !includes(DIM, colNum)) {\n    throw new Error(\"rowNum or colNum are not in range\");\n  }\n\n  if (!includes(VALUES, number)) {\n    throw new Error(\"number is not in range\");\n  }\n\n  let row = getRow(grid, rowNum);\n  let column = getCol(grid, colNum);\n  let square = getSquare(grid, rowNum, colNum);\n\n  if (\n    !includes(row, number) &&\n    !includes(column, number) &&\n    !includes(square, number)\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\n/*\n\tstarts from 0x0 and moves left to right and row by row to 9x9\n*/\nconst getNext = (rowNum = 0, colNum = 0) => {\n  return colNum !== 8\n    ? [rowNum, colNum + 1]\n    : rowNum !== 8\n    ? [rowNum + 1, 0]\n    : [0, 0];\n};\n\n/*\n\tRecursive formula that starts from [0, 0] and check\n\tall the possbile values for empty boxes until it reaches\n\tthe end of the grid and returns true\n\tor else if the grid is not solvable, it will return false\n*/\nexport const solver = (grid, rowNum = 0, colNum = 0) => {\n  if (includes(DIM, rowNum) < 0 || includes(DIM, colNum) < 0) {\n    throw new Error(\"rowNum or colNum are not in range\");\n  }\n  let isLast = rowNum >= 8 && colNum >= 8;\n\n  /* if the box is not empty, run the solver on the next box */\n  if (grid[rowNum][colNum] !== ZERO && !isLast) {\n    let [nextRowNum, nextColNum] = getNext(rowNum, colNum);\n    return solver(grid, nextRowNum, nextColNum);\n  }\n  /*\n\t\tif the box is empty, check to see out of numbers 1 to 9,\n\t\twhich one satisfies all three sudoko constraints\n\t*/\n\n  for (let i = 1; i <= 9; i++) {\n    if (check(grid, i, rowNum, colNum)) {\n      grid[rowNum][colNum] = i;\n      let [nextRowNum, nextColNum] = getNext(rowNum, colNum);\n      /*\n\t\t\t\truns the solver recusively until it sucessfully\n\t\t\t\treaches to the end of the grid, box 9x9\n\t\t\t*/\n      if (!nextRowNum && !nextColNum) {\n        // at index [8, 8], next would be [0, 0]\n        return true;\n      }\n      if (solver(grid, nextRowNum, nextColNum)) {\n        return true;\n      }\n    }\n  }\n\n  /*\n\t\tif the loop could not solve and return the function,\n\t\tfalse will be retuened which indicates the sudoku is not solvable.\n\t\tresets the current state back to 0 allow for further tries\n\t*/\n  grid[rowNum][colNum] = ZERO;\n  return false;\n};\n\nexport const isSolvable = grid => {\n  let clonedGrid = cloneDeep(grid);\n  return solver(clonedGrid);\n};\n\n/*\n\tIf each of the numbers from 1 to 9 are repeated on the grid 9 times\n\tindicates the suduko is completed/solved\n*/\nexport const isComplete = grid => {\n  let values = flatten(grid);\n  let list = {};\n  values.map(val => (list[val] = list[val] ? list[val] + 1 : 1));\n  delete list[\"0\"];\n  var total = Object.keys(list).reduce((total, key) => total + list[key], 0);\n  return total === 81 ? true : false;\n};\n"]},"metadata":{},"sourceType":"module"}