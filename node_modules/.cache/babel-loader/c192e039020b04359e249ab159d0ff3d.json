{"ast":null,"code":"import _slicedToArray from \"/home/lambamansha/Desktop/minorproject/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport cloneDeep from 'lodash/cloneDeep';\nimport flatten from 'lodash/flatten';\nimport range from 'lodash/range';\nimport includes from 'lodash/includes';\nconst VALUES = range(1, 10);\nconst DIM = range(0, 9);\nconst ZERO = 0;\n\nconst getRow = (grid, rowNum) => {\n  if (!contains(DIM, rowNum)) {\n    throw new Error('rowNum not in range');\n  }\n\n  return grid[rowNum];\n};\n\nconst getCol = (grid, colNum) => {\n  if (!contains(DIM, colNum)) {\n    throw new Error('colNum not in range');\n  }\n\n  return grid.map(row => row[colNum]);\n};\n\nconst getSquare = (grid, rowNum, colNum) => {\n  if (!contains(DIM, rowNum) || !contains(DIM, colNum)) {\n    throw new Error('rowNum or colNum are not in range');\n  }\n\n  let rowStart = rowNum - rowNum % 3; // uppermost row index of the box\n\n  let colStart = colNum - colNum % 3; // leftmost col index of the box\n\n  let result = [];\n\n  for (let i = 0; i < 3; i++) {\n    result[i] = result[i] || [];\n\n    for (let j = 0; j < 3; j++) {\n      result[i].push(grid[rowStart + i][colStart + j]);\n    }\n  }\n\n  return flatten(result);\n};\n/*\n\tsudoku constraints checker\n\t- unique in its row\n\t- unique in its column\n\t- unique in its box\n*/\n\n\nconst check = (grid, number, rowNum, colNum) => {\n  if (!contains(DIM, rowNum) || !contains(DIM, colNum)) {\n    throw new Error('rowNum or colNum are not in range');\n  }\n\n  if (!contains(VALUES, number)) {\n    throw new Error('number is not in range');\n  }\n\n  let row = getRow(grid, rowNum);\n  let column = getCol(grid, colNum);\n  let square = getSquare(grid, rowNum, colNum);\n\n  if (!contains(row, number) && !contains(column, number) && !contains(square, number)) {\n    return true;\n  }\n\n  return false;\n};\n/*\n\tstarts from 0x0 and moves left to right and row by row to 9x9\n*/\n\n\nconst getNext = (rowNum = 0, colNum = 0) => {\n  return colNum !== 8 ? [rowNum, colNum + 1] : rowNum !== 8 ? [rowNum + 1, 0] : [0, 0];\n};\n/*\n\tRecursive formula that starts from [0, 0] and check\n\tall the possbile values for empty boxes until it reaches\n\tthe end of the grid and returns true\n\tor else if the grid is not solvable, it will return false\n*/\n\n\nexport const solver = (grid, rowNum = 0, colNum = 0) => {\n  if (contains(DIM, rowNum) < 0 || contains(DIM, colNum) < 0) {\n    throw new Error('rowNum or colNum are not in range');\n  }\n\n  let isLast = rowNum >= 8 && colNum >= 8;\n  /* if the box is not empty, run the solver on the next box */\n\n  if (grid[rowNum][colNum] !== ZERO && !isLast) {\n    let _getNext = getNext(rowNum, colNum),\n        _getNext2 = _slicedToArray(_getNext, 2),\n        nextRowNum = _getNext2[0],\n        nextColNum = _getNext2[1];\n\n    return solver(grid, nextRowNum, nextColNum);\n  }\n  /*\n  \tif the box is empty, check to see out of numbers 1 to 9,\n  \twhich one satisfies all three sudoko constraints\n  */\n\n\n  for (let i = 1; i <= 9; i++) {\n    if (check(grid, i, rowNum, colNum)) {\n      grid[rowNum][colNum] = i;\n\n      let _getNext3 = getNext(rowNum, colNum),\n          _getNext4 = _slicedToArray(_getNext3, 2),\n          nextRowNum = _getNext4[0],\n          nextColNum = _getNext4[1];\n      /*\n      \truns the solver recusively until it sucessfully\n      \treaches to the end of the grid, box 9x9\n      */\n\n\n      if (!nextRowNum && !nextColNum) {\n        // at index [8, 8], next would be [0, 0]\n        return true;\n      }\n\n      if (solver(grid, nextRowNum, nextColNum)) {\n        return true;\n      }\n    }\n  }\n  /*\n  \tif the loop could not solve and return the function,\n  \tfalse will be retuened which indicates the sudoku is not solvable.\n  \tresets the current state back to 0 allow for further tries\n  */\n\n\n  grid[rowNum][colNum] = ZERO;\n  return false;\n};\nexport const isSolvable = grid => {\n  let clonedGrid = cloneDeep(grid);\n  return solver(clonedGrid);\n};\n/*\n\tIf each of the numbers from 1 to 9 are repeated on the grid 9 times\n\tindicates the suduko is completed/solved\n*/\n\nexport const isComplete = grid => {\n  let values = flatten(grid);\n  let list = {};\n  values.map(val => list[val] = list[val] ? list[val] + 1 : 1);\n  delete list['0'];\n  var total = Object.keys(list).reduce((total, key) => total + list[key], 0);\n  return total === 81 ? true : false;\n};","map":{"version":3,"sources":["/home/lambamansha/Desktop/minorproject/src/views/QuizList/utils/sudoku.js"],"names":["cloneDeep","flatten","range","includes","VALUES","DIM","ZERO","getRow","grid","rowNum","contains","Error","getCol","colNum","map","row","getSquare","rowStart","colStart","result","i","j","push","check","number","column","square","getNext","solver","isLast","nextRowNum","nextColNum","isSolvable","clonedGrid","isComplete","values","list","val","total","Object","keys","reduce","key"],"mappings":"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","sourcesContent":["import cloneDeep from 'lodash/cloneDeep';\nimport flatten from 'lodash/flatten';\nimport range from 'lodash/range';\nimport includes from 'lodash/includes';\n\nconst VALUES = range(1, 10);\nconst DIM = range(0, 9);\nconst ZERO = 0;\n\nconst getRow = (grid, rowNum) => {\n\tif (!contains(DIM, rowNum)) {\n\t\tthrow new Error('rowNum not in range');\n\t}\n\treturn grid[rowNum];\n}\n\nconst getCol = (grid, colNum) => {\n\tif (!contains(DIM, colNum)) {\n\t\tthrow new Error('colNum not in range');\n\t}\n\treturn grid.map((row) => row[colNum]);\n}\n\nconst getSquare = (grid, rowNum, colNum) => {\n\tif (!contains(DIM, rowNum) || !contains(DIM, colNum)) {\n\t\tthrow new Error('rowNum or colNum are not in range');\n\t}\n\tlet rowStart = rowNum - (rowNum % 3); // uppermost row index of the box\n\tlet colStart = colNum - (colNum % 3); // leftmost col index of the box\n\tlet result = [];\n\tfor (let i = 0; i < 3; i++) {\n\t\tresult[i] = result[i] || [];\n\t\tfor (let j = 0; j < 3; j++) {\n\t\t\tresult[i].push(grid[rowStart + i][colStart + j]);\n\t\t}\n\t}\n\treturn flatten(result);\n}\n\n/*\n\tsudoku constraints checker\n\t- unique in its row\n\t- unique in its column\n\t- unique in its box\n*/ \nconst check = (grid, number, rowNum, colNum) => {\n\tif (!contains(DIM, rowNum) || !contains(DIM, colNum)) {\n\t\tthrow new Error('rowNum or colNum are not in range');\n\t}\n\n\tif (!contains(VALUES, number)) {\n\t\tthrow new Error('number is not in range');\n\t}\n\n\tlet row = getRow(grid, rowNum);\n\tlet column = getCol(grid, colNum);\n\tlet square = getSquare(grid, rowNum, colNum);\n\n\tif (!contains(row, number) && !contains(column, number) && !contains(square, number)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n/*\n\tstarts from 0x0 and moves left to right and row by row to 9x9\n*/\nconst getNext = (rowNum = 0, colNum = 0) => {\n\treturn colNum !== 8 ? [rowNum, colNum + 1] :\n\t\trowNum !== 8 ? [rowNum + 1, 0] :\n\t\t[0, 0];\n}\n\n/*\n\tRecursive formula that starts from [0, 0] and check\n\tall the possbile values for empty boxes until it reaches\n\tthe end of the grid and returns true\n\tor else if the grid is not solvable, it will return false\n*/\nexport const solver = (grid, rowNum = 0, colNum = 0) => {\n\tif (contains(DIM, rowNum) < 0 || contains(DIM, colNum) < 0) {\n\t\tthrow new Error('rowNum or colNum are not in range');\n\t}\n\tlet isLast = (rowNum >= 8 && colNum >= 8);\n\n\t/* if the box is not empty, run the solver on the next box */\n\tif (grid[rowNum][colNum] !== ZERO && !isLast) {\n\t\tlet [nextRowNum, nextColNum] = getNext(rowNum, colNum);\n\t\treturn solver(grid, nextRowNum, nextColNum);\n\t}\n\t/*\n\t\tif the box is empty, check to see out of numbers 1 to 9,\n\t\twhich one satisfies all three sudoko constraints\n\t*/ \n\tfor (let i = 1; i <= 9; i++) {\n\t\tif (check(grid, i, rowNum, colNum)) {\n\t\t\tgrid[rowNum][colNum] = i;\n\t\t\tlet [nextRowNum, nextColNum] = getNext(rowNum, colNum);\n\t\t\t/*\n\t\t\t\truns the solver recusively until it sucessfully\n\t\t\t\treaches to the end of the grid, box 9x9\n\t\t\t*/\n\t\t\tif (!nextRowNum && !nextColNum) { // at index [8, 8], next would be [0, 0]\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (solver(grid, nextRowNum, nextColNum)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t\tif the loop could not solve and return the function,\n\t\tfalse will be retuened which indicates the sudoku is not solvable.\n\t\tresets the current state back to 0 allow for further tries\n\t*/\n\tgrid[rowNum][colNum] = ZERO;\n\treturn false;\n}\n\nexport const isSolvable = (grid) => {\n\tlet clonedGrid = cloneDeep(grid);\n\treturn solver(clonedGrid);\n}\n\n/*\n\tIf each of the numbers from 1 to 9 are repeated on the grid 9 times\n\tindicates the suduko is completed/solved\n*/\nexport const isComplete = (grid) => {\n\tlet values = flatten(grid);\n\tlet list = {};\n\tvalues.map((val) => list[val] = list[val] ? list[val] + 1 : 1);\n\tdelete list['0'];\n\tvar total = Object.keys(list).reduce((total, key) => total + list[key], 0);\n\treturn total === 81 ? true : false;\n}\n"]},"metadata":{},"sourceType":"module"}